/******************************************************************************
** Test: Twin-Diff
** This test simulates code generated by the CARTS compiler to verify that
** twin-diff correctly preserves concurrent non-overlapping writes across
** multiple nodes.
******************************************************************************/
#include "arts/arts.h"
#include "arts/runtime/memory/TwinDiff.h"
#include "arts/system/ArtsPrint.h"
#include <stdlib.h>

/// Configurable test parameters
/// Matrix: 256x256 = 512 KB
/// Tiles:  32x32 = 8 KB per tile
/// Result: 8x8 = 64 tiles
unsigned int matrixDim = 256;
unsigned int tileDim = 32;

/// Computed values
#define TILES_PER_ROW (matrixDim / tileDim)
#define TOTAL_TILES (TILES_PER_ROW * TILES_PER_ROW)

artsGuid_t matrixGuid;
volatile unsigned int *validationResult = NULL;

// Writer EDT: Writes to a specific non-overlapping tile
void tileWriter(uint32_t paramc, uint64_t *paramv, uint32_t depc,
                artsEdtDep_t depv[]) {
  ARTS_PRINT("[tileWriter] entry paramc=%u depc=%u paramv=%p depv=%p", paramc,
             depc, (void *)paramv, (void *)depv);
  if (paramc == 0 || !paramv) {
    ARTS_ERROR("[tileWriter] Missing tile id param (paramc=%u, paramv=%p)",
               paramc, (void *)paramv);
    return;
  }
  if (depc == 0 || !depv || depv[0].ptr == NULL) {
    ARTS_ERROR(
        "[tileWriter] Missing matrix DB (depc=%u, depv=%p, depv[0].ptr=%p)",
        depc, (void *)depv, depv ? depv[0].ptr : NULL);
    return;
  }

  unsigned int tileId = (unsigned int)paramv[0];
  unsigned int nodeId = artsGetCurrentNode();

  uint64_t *matrix = (uint64_t *)depv[0].ptr;

  // Calculate tile boundaries (non-overlapping)
  unsigned int tilesPerRow = matrixDim / tileDim;
  unsigned int tileRow = tileId / tilesPerRow;
  unsigned int tileCol = tileId % tilesPerRow;
  unsigned int startRow = tileRow * tileDim;
  unsigned int startCol = tileCol * tileDim;

  ARTS_PRINT("Node %u - Writing tile %u (rows %u-%u, cols %u-%u)", nodeId,
             tileId, startRow, startRow + tileDim - 1, startCol,
             startCol + tileDim - 1);

  ARTS_PRINT("Node %u - Tile %u - mode=%u, acquireMode=%u, useTwinDiff=%d",
             nodeId, tileId, depv[0].mode, depv[0].acquireMode,
             depv[0].useTwinDiff);

  // Write unique pattern to this tile: (tileId << 48) | (row << 24) | col
  for (unsigned int i = 0; i < tileDim; i++) {
    for (unsigned int j = 0; j < tileDim; j++) {
      unsigned int row = startRow + i;
      unsigned int col = startCol + j;
      unsigned int idx = row * matrixDim + col;
      matrix[idx] = ((uint64_t)tileId << 48) | ((uint64_t)row << 24) | col;
    }
  }

  ARTS_PRINT("Node %u - Completed writing tile %u", nodeId, tileId);
}

// Validator EDT: Verifies all tiles were written correctly
void validator(uint32_t paramc, uint64_t *paramv, uint32_t depc,
               artsEdtDep_t depv[]) {
  uint64_t *matrix = (uint64_t *)depv[0].ptr;
  bool success = true;
  unsigned int errors = 0;
  bool twinHintCorrect = !depv[0].useTwinDiff;
  unsigned int totalTiles = (matrixDim / tileDim) * (matrixDim / tileDim);
  unsigned int tilesPerRow = matrixDim / tileDim;

  ARTS_PRINT("[Validator] Checking all %u tiles...", totalTiles);
  ARTS_PRINT("[Validator] Acquired DB with acquireMode=%u, useTwinDiff=%d",
             depv[0].acquireMode, depv[0].useTwinDiff);
  if (!twinHintCorrect) {
    ARTS_ERROR("[Validator] ERROR: Compiler requested useTwinDiff=false for "
               "final READ, "
               "but runtime delivered useTwinDiff=%d",
               depv[0].useTwinDiff);
    success = false;
  }

  for (unsigned int tileId = 0; tileId < totalTiles; tileId++) {
    unsigned int tileRow = tileId / tilesPerRow;
    unsigned int tileCol = tileId % tilesPerRow;
    unsigned int startRow = tileRow * tileDim;
    unsigned int startCol = tileCol * tileDim;

    for (unsigned int i = 0; i < tileDim; i++) {
      for (unsigned int j = 0; j < tileDim; j++) {
        unsigned int row = startRow + i;
        unsigned int col = startCol + j;
        unsigned int idx = row * matrixDim + col;

        uint64_t expected =
            ((uint64_t)tileId << 48) | ((uint64_t)row << 24) | col;
        uint64_t actual = matrix[idx];

        if (actual != expected) {
          // Print first 5 errors only
          if (errors < 5) {
            ARTS_ERROR("ERROR at tile %u [%u,%u]: expected 0x%lx, got 0x%lx",
                       tileId, row, col, expected, actual);
          }
          errors++;
          success = false;
        }
      }
    }
  }

  if (success && twinHintCorrect) {
    ARTS_PRINT("TEST STATUS: SUCCESS");
    ARTS_PRINT("SUCCESS: All %u tiles validated correctly!", totalTiles);
    ARTS_PRINT("Twin-diff preserved %u concurrent non-overlapping writes.",
               totalTiles);
    if (validationResult)
      *validationResult = 1;
  } else {
    ARTS_PRINT("TEST STATUS: FAILURE");
    ARTS_PRINT("FAILURE: Found %u errors in matrix!", errors);
    ARTS_PRINT("Twin-diff may have failed to preserve non-overlapping writes.");
    if (validationResult)
      *validationResult = 0;
  }
}

void artsMain(int argc, char **argv) {
  /// Parse command line arguments for parametric testing
  /// Usage: ./testTwinDiffCompilerPattern [matrixDim] [tileDim]

  /// Parse matrixDim
  if (argc > 1 && argv[1])
    matrixDim = (unsigned int)atoi(argv[1]);

  /// Parse tileDim
  if (argc > 2 && argv[2])
    tileDim = (unsigned int)atoi(argv[2]);

  /// Validate parameters
  if (matrixDim % tileDim != 0) {
    ARTS_PRINT("ERROR: matrixDim (%u) must be divisible by tileDim (%u)",
               matrixDim, tileDim);
    artsShutdown();
    return;
  }

  unsigned int totalTiles = (matrixDim / tileDim) * (matrixDim / tileDim);
  unsigned int matrixElements = matrixDim * matrixDim;
  unsigned int matrixSize = matrixElements * sizeof(uint64_t);

  ARTS_PRINT("Twin-Diff Test");
  ARTS_PRINT("- Matrix: %ux%u (%zu MB)", matrixDim, matrixDim,
             matrixSize / (1024 * 1024));
  ARTS_PRINT("- Tiles:  %ux%u per tile, %u total tiles", tileDim, tileDim,
             totalTiles);
  ARTS_PRINT("- Nodes:  %u", artsGetTotalNodes());

  // Create matrix DB and initialize to zeros
  matrixGuid = artsReserveGuidRoute(ARTS_DB_WRITE, 0);
  ARTS_PRINT("Node 0: Creating Matrix Db (guid: %lu)", matrixGuid);
  uint64_t *matrixPtr =
      (uint64_t *)artsDbCreateWithGuid(matrixGuid, matrixSize);
  for (unsigned int i = 0; i < matrixElements; i++)
    matrixPtr[i] = 0;
  ARTS_PRINT("Matrix Db initialized to zeros");

  // Allocate validation result flag
  validationResult = (volatile unsigned int *)artsMalloc(sizeof(unsigned int));
  *validationResult = 0;

  // Start epoch
  artsGuid_t epochGuid = artsInitializeAndStartEpoch(NULL_GUID, 0);
  ARTS_PRINT("[Step 1] Started epoch (guid: %lu)", epochGuid);

  // Create validator EDT
  artsGuid_t validatorGuid =
      artsEdtCreateWithEpoch(validator, 0, 0, NULL, 1, epochGuid);
  ARTS_PRINT("[Step 2] Created validator EDT (guid: %lu)", validatorGuid);

  // Create writer EDTs
  ARTS_PRINT("[Step 3] Creating %u writer EDTs: ", totalTiles);
  artsGuid_t *writerGuids =
      (artsGuid_t *)artsMalloc(totalTiles * sizeof(artsGuid_t));
  for (unsigned int tileId = 0; tileId < totalTiles; tileId++) {
    unsigned int targetNode = (tileId % artsGetTotalNodes());
    uint64_t param = tileId;
    writerGuids[tileId] =
        artsEdtCreateWithEpoch(tileWriter, targetNode, 1, &param, 1, epochGuid);

    if ((tileId + 1) % 8 == 0 || tileId == totalTiles - 1) {
      unsigned int rangeStart = (tileId / 8) * 8;
      unsigned int rangeEnd = tileId;
      ARTS_PRINT("Created writer EDTs %u-%u in Node %u", rangeStart, rangeEnd,
                 targetNode);
    }
  }

  // Record ALL dependencies
  ARTS_PRINT("[Step 4] Recording dependencies for %u writers + 1 validator",
             totalTiles);
  for (unsigned int tileId = 0; tileId < totalTiles; tileId++)
    artsRecordDep(matrixGuid, writerGuids[tileId], 0, ARTS_DB_WRITE, true);

  // Record validator dependency (READ mode)
  artsRecordDep(matrixGuid, validatorGuid, 0, ARTS_DB_READ, false);

  ARTS_PRINT("[Step 5] Waiting for epoch to complete");
  artsWaitOnHandle(epochGuid);

  artsFree(writerGuids);

  // Print final status
  if (validationResult && *validationResult == 1)
    ARTS_PRINT("[TEST STATUS] SUCCESS");
  else
    ARTS_PRINT("[TEST STATUS] FAILURE");

  // Shutdown runtime
  artsShutdown();
}

int main(int argc, char **argv) {
  artsRT(argc, argv);
  return 0;
}
